matrix(data = apply(X = D_gct[, , Years2Include],
MARGIN = c(1, 2),
FUN = sum),
ncol = ns_all,
dimnames = list(NULL, paste0("Y", 1:ns_all))),
matrix(data = apply(X = D_gct[, , Years2Include],
MARGIN = c(1, 2),
FUN = function(x) sum(x^2)),
ncol = ns_all,
dimnames = list(NULL, paste0("Y", 1:ns_all, "_SQ_SUM")))
)
##################################
## Import Strata Allocations and spatial grid and predicted density
##################################
GOA_allocations <- readxl::read_xlsx(
path = paste0(github_dir, '/data/GOA 2019 stations by stratum.xlsx')
)
GOA_allocations3 <- readxl::read_xlsx(
path = paste0(github_dir, '/data/GOA2019_ 3 boat_825_RNDM_stations.xlsx')
)
##################################################
####   Create dataframe of effort allocations across boats
##################################################
allocations <- data.frame(Stratum = sort(unique(GOA_allocations3$stratum)),
boat3 = aggregate(id ~ stratum,
data = GOA_allocations3,
FUN = length)$id,
boat2 = c(GOA_allocations$`Number stations`,
rep(0,5)))
allocations$boat1 = ceiling(allocations$boat2 / 2)
allocations$boat1 = ifelse(allocations$boat1 == 0, 0,
ifelse(allocations$boat1 == 1, 2,
allocations$boat1))
allocations <- rbind(c("Stratum" = 0, "boat3" = 0, "boat2" = 0, "boat1" = 0),
allocations)
##################################
## Calculate Population CVs under Simple Random Sampling
##################################
frame_SRS <- subset(frame,
select = c("domainvalue", "id", "WEIGHT",
paste0("Y", 1:ns_all),
paste0("Y", 1:ns_all, "_SQ_SUM")))
frame_SRS$X1 = cut(x = Extrapolation_depths$Lon,
breaks = c(-170, -159, -154, -147, -140, -132),
labels = 1:5)
SRS_mean_sds <- buildStrataDF(dataset = frame_SRS)
SRS_Pop_CV <- lapply(X = 1:nboats,
FUN = function(x) {
n = samples[x] / ndom
N = table(frame$domainvalue)[x]
temp_mean <- SRS_mean_sds[, paste0("M", 1:ns_all)]
temp_var <- SRS_mean_sds[, paste0("S", 1:ns_all)]^2
temp_var <- temp_var / n * (1 - n/N)
temp_sd <- sqrt(temp_var)
temp_cv <- temp_sd / temp_mean
colnames(temp_cv) <- sci_names_all
return(temp_cv)
})
##################################
## Calculate Population CVs under current STRS sampling
##################################
# Current_STRS_Pop_CV <- matrix(nrow = ns_all,
#                               ncol = nboats,
#                               dimnames = list(sci_names_all, NULL))
#
# for (iboat in 1:nboats) {
#   #Adjust sample size proportionally
#   nh <- allocations[, paste0('boat', iboat)]
#
#   #strata constraints
#   # strata_labels <- paste(allocations$Stratum[sampled_strata])
#   Nh <- table(Extrapolation_depths$stratum)
#   Wh <- Nh / N
#   wh <- nh / Nh
#
#   #Calculate Strata means and sds (calculated over time as well)
#   frame_current <- subset(frame,
#                           select = c("domainvalue", "id", "WEIGHT",
#                                      paste0("Y", 1:ns_all),
#                                      paste0("Y", 1:ns_all, "_SQ_SUM")))
#   frame_current$X1 = Extrapolation_depths$stratum
#   frame_current$X1[is.na(frame_current$X1)] <- 0
#
#   STRS_mean_sds <- buildStrataDF(dataset = frame_current)
#
#   STRS_mean <- colSums(sweep(x = STRS_mean_sds[, paste0("M", 1:ns_all)],
#                              MARGIN = 1,
#                              STATS = Wh,
#                              FUN = '*'))
#
#   STRS_var_temp <- sweep(x = STRS_mean_sds[, paste0("S", 1:ns_all)]^2,
#                          MARGIN = 1,
#                          STATS = Wh^2 * (1 - wh) / nh,
#                          FUN = '*')
#
#   ## For those strata with zero effort allocated
#   STRS_var_temp <- apply(X = STRS_var_temp,
#                          MARGIN = 1:2,
#                          FUN = function(x) ifelse(is.finite(x), x, 0))
#
#   STRS_var <- colSums(STRS_var_temp)
#
#   strata_cv <- sqrt(STRS_var) / STRS_mean
#
#   Current_STRS_Pop_CV[, iboat ] <- strata_cv
# }
settings_by_dom
SRS_Pop_CV
settings_by_dom
str(SRS_Pop_CV)
SS_STRS_Pop_CV = list()
SS_STRS_Pop_CV <- list()
nboats
iboat = 1
subset(x = settings_by_dom,
subset = iboat == iboat)
settings_by_dom
subset(x = settings_by_dom,
subset = settings_by_dom$iboat == iboat)
settings_by_dom$iboat
iboat
subset(x = settings_by_dom,
subset = settings_by_dom$iboat == iboat)
settings_by_dom[settings_by_dom$iboat == iboat,]
settings_by_dom[settings_by_dom$iboat == iboat, paste(1:ndom)]
t(settings_by_dom[settings_by_dom$iboat == iboat, paste(1:ndom)])
t(settings_by_dom[settings_by_dom$iboat == iboat, paste(1:ndom)])
SRS_Pop_CV
as.matrix
?as.matrix()
?as.matrix
sci_names_all
SS_STRS_Pop_CV[[iboat]] <-
as.matrix(t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(NULL, sci_names_all))
SS_STRS_Pop_CV
SS_STRS_Pop_CV[[iboat]] <-
matrix(t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(NULL, sci_names_all))
matrix(t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(NULL, sci_names_all))
sci_names_all
dim(t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]))
SS_STRS_Pop_CV[[iboat]] <-
matrix(t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(NULL, sci_names_opt))
sci_names_opt
t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)])
as.matrix(x = t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(NULL, sci_names_opt))
matrix(data = t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(NULL, sci_names_opt))
sci_names_opt
str(t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]))
sci_names_opt
matrix(data = t(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(NULL, sci_names_opt))
matrix(data = settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)],
dimnames = list(sci_names_opt, NULL))
str(sci_names_opt)
str(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)])
as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)])
matrix(data = as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(sci_names_opt, NULL))
str(as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]))
list(sci_names_opt, NULL)
matrix(data = as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]),
dimnames = list(sci_names_opt, NULL))
SS_STRS_Pop_CV[[iboat]] <-
as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)])
colnames( SS_STRS_Pop_CV[[iboat]])
SS_STRS_Pop_CV[[iboat]] <-
t(as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]))
SS_STRS_Pop_CV[[iboat]] <-
t(as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]))
colnames( SS_STRS_Pop_CV[[iboat]])
colnames( SS_STRS_Pop_CV[[iboat]]) <- sci_names_opt
SS_STRS_Pop_CV <- list()
iboat = 1
for (iboat in 1:nboats) {
SS_STRS_Pop_CV[[iboat]] <-
t(as.matrix(settings_by_dom[settings_by_dom$iboat == iboat,
paste(1:ndom)]))
colnames( SS_STRS_Pop_CV[[iboat]]) <- sci_names_opt
}
SS_STRS_Pop_CV
source('~/GitHub/Optimal_Allocation_GoA/analysis_scripts/Calculate_Population_Variances.R', echo=TRUE)
SRS_Pop_CV
SS_STRS_Pop_CV
str(SRS_Pop_CV)
str(SS_STRS_Pop_CV)
source('~/GitHub/Optimal_Allocation_GoA/analysis_scripts/Calculate_Population_Variances.R', echo=TRUE)
###############################################################################
## Project:       Spatiotemporal Survey Optimization
## Author:        Zack Oyafuso (zack.oyafuso@noaa.gov)
## Description:   Conduct SamplingStrata R package multispecies stratified
##                survey optimization
###############################################################################
rm(list = ls())
##################################################
####   Set up directories based on whether the optimization is being conducted
####        on a multi-species or single-species level
##################################################
which_machine <- c("Zack_MAC" = 1, "Zack_PC" = 2, "Zack_GI_PC" = 3)[3]
github_dir <- paste0(c("/Users/zackoyafuso/Documents",
"C:/Users/Zack Oyafuso/Documents",
"C:/Users/zack.oyafuso/Work")[which_machine],
"/GitHub/Optimal_Allocation_GoA/results/",
"Spatiotemporal_Optimization/")
##################################################
####  Install a forked version of the SamplingStrata Package from
####  zoyafuso-NOAA's Github page
####
####  Import other required packages
##################################################
library(devtools)
devtools::install_github(repo = "zoyafuso-NOAA/SamplingStrata")
library(SamplingStrata)
library(sp)
library(RColorBrewer)
library(raster)
##################################################
####   Load Data
####   Load Population CVs for use in the thresholds
##################################################
load(paste0(dirname(dirname(github_dir)), "/data/optimization_data.RData"))
load(paste0(dirname(dirname(github_dir)), "/data/Extrapolation_depths.RData"))
load(paste0(dirname(github_dir), "/Population_Variances.RData"))
##################################################
####   Run optimization
##################################################
#Choose a boat level
isample <- 1
istrata <- 1
##Initial Condition
Run <- 1
current_n <- 0
#Create CV dataframe
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv[, paste0("CV", length(which_species))] <-
SRS_Pop_CV[[isample]][, which_species]
spp_idx_opt
#Create CV dataframe
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv
cv[, paste0("CV", 1:ns_opt )] <-
SRS_Pop_CV[[isample]][, spp_idx_opt]
cv
SRS_Pop_CV[[isample]][, spp_idx_opt]
SS_STRS_Pop_CV[[isample]][, spp_idx_opt]
SS_STRS_Pop_CV[[isample]][, ]
SS_STRS_Pop_CV[[2]][, spp_idx_opt]
SRS_Pop_CV[[2]][, spp_idx_opt]
SS_STRS_Pop_CV[[2]]
##Initial Condition
Run <- 1
current_n <- 0
#Create CV dataframe
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv[, paste0("CV", 1:ns_opt )] <-
SRS_Pop_CV[[isample]][, spp_idx_opt]
#Set wd for output files, create a directory if it doesn"t exist yet
temp_dir = paste0(github_dir, "boat", isample, "/Str", temp_strata,
"Run", Run)
#Set wd for output files, create a directory if it doesn"t exist yet
temp_dir = paste0(github_dir, "boat", isample, "/Run", Run)
temp_dir
if(!dir.exists(temp_dir)) dir.create(temp_dir, recursive = T)
setwd(temp_dir)
#Run optimization
solution <- optimStrata(method = "continuous",
errors = cv,
framesamp = frame,
iter = 30,
pops = 30,
elitism_rate = 0.1,
mut_chance = 1 / (c(5,5,5,5,5) + 1),
nStrata = c(5,5,5,5,5),
showPlot = T,
writeFiles = F,
parallel = T)
#Run optimization
solution <- optimStrata(method = "continuous",
errors = cv,
framesamp = frame,
iter = 30,
pops = 30,
elitism_rate = 0.1,
mut_chance = 1 / (c(5,5,5,5,5) + 1),
nStrata = c(5,5,5,5,5),
showPlot = T,
writeFiles = T,
parallel = T)
sum_stats <- summaryStrata(solution$framenew,
solution$aggr_strata,
progress=FALSE)
plot_solution <- as.factor(paste(solution$framenew$DOMAINVALUE,
solution$framenew$STRATO))
plot_solution <- as.integer(plot_solution)
#Plot Solution
goa <- sp::SpatialPointsDataFrame(
coords = Extrapolation_depths[,c("E_km", "N_km")],
data = data.frame(Str_no = plot_solution) )
goa_ras <- raster::raster(x = goa,
resolution = 5)
goa_ras <- raster::rasterize(x = goa,
y = goa_ras,
field = "Str_no")
plot(goa_ras, axes = F,
col = sample(terrain.colors(20)) )
SS_STRS_Pop_CV
SS_STRS_Pop_CV[[isample]]
CV_constraints
#Save Output
CV_constraints <- expected_CV(strata = solution$aggr_strata)
current_n <- sum(sum_stats$Allocation)
current_n
CV_constraints
0.95*CV_constraints
0.05*(SS_STRS_Pop_CV[[isample]]
)
0.95*CV_constraints + 0.05*(SS_STRS_Pop_CV[[isample]])
0.95*CV_constraints
SRS_Pop_CV[[1]]
#Set up next run by changing upper CV constraints
Run <- Run + 1
CV_constraints <- 0.95*CV_constraints + 0.05*(SS_STRS_Pop_CV[[isample]])
#Create CV dataframe in the formmat of SamplingStrata
cv <- list()
for (spp in 1:ns_opt)
cv[[paste0("CV", spp)]] <- as.numeric(CV_constraints[spp])
cv[["DOM"]] <- 1
cv[["domainvalue"]] <- 1
cv <- as.data.frame(cv)
cv
#Create CV dataframe in the formmat of SamplingStrata
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv[, paste0("CV", 1:ns_opt )] <- CV_constraints
cv
#Run optimization
solution <- optimStrata(method = "continuous",
errors = cv,
framesamp = frame,
iter = 300,
pops = 30,
elitism_rate = 0.1,
mut_chance = 1 / (c(5,5,5,5,5) + 1),
nStrata = c(5,5,5,5,5),
showPlot = T,
writeFiles = T,
parallel = T)
for (istrata in 1:3) {
##Initial Condition
Run <- 1
current_n <- 0
#Create CV dataframe
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv[, paste0("CV", 1:ns_opt )] <-
SRS_Pop_CV[[isample]][, spp_idx_opt]
while (current_n <= c(280, 550, 820)[isample] ) {
#Set wd for output files, create a directory if it doesn"t exist yet
temp_dir = paste0(github_dir, "boat", isample, "/Run", Run)
if(!dir.exists(temp_dir)) dir.create(temp_dir, recursive = T)
setwd(temp_dir)
#Run optimization
solution <- optimStrata(method = "continuous",
errors = cv,
framesamp = frame,
iter = 300,
pops = 30,
elitism_rate = 0.1,
mut_chance = 1 / (c(5,5,5,5,5) + 1),
nStrata = c(5,5,5,5,5),
showPlot = T,
writeFiles = T,
parallel = T)
sum_stats <- summaryStrata(solution$framenew,
solution$aggr_strata,
progress=FALSE)
plot_solution <- as.factor(paste(solution$framenew$DOMAINVALUE,
solution$framenew$STRATO))
plot_solution <- as.integer(plot_solution)
#Plot Solution
goa <- sp::SpatialPointsDataFrame(
coords = Extrapolation_depths[,c("E_km", "N_km")],
data = data.frame(Str_no = plot_solution) )
goa_ras <- raster::raster(x = goa,
resolution = 5)
goa_ras <- raster::rasterize(x = goa,
y = goa_ras,
field = "Str_no")
png(filename = "solution.png",
width = 5,
height = 5,
units = "in",
res = 500)
plot(goa_ras, axes = F,
col = sample(terrain.colors(20)) )
dev.off()
#Save Output
CV_constraints <- expected_CV(strata = solution$aggr_strata)
current_n <- sum(sum_stats$Allocation)
result_list <- list(solution = solution,
sum_stats = sum_stats,
CV_constraints = CV_constraints,
n = current_n)
save(list = "result_list", file = "result_list.RData")
#Set up next run by changing upper CV constraints
Run <- Run + 1
CV_constraints <- 0.95*CV_constraints + 0.05*(SS_STRS_Pop_CV[[isample]])
#Create CV dataframe in the formmat of SamplingStrata
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv[, paste0("CV", 1:ns_opt )] <- CV_constraints
}
}
##################################################
####   Run optimization
##################################################
#Choose a boat level
isample <- 1
##Initial Condition
Run <- 1
current_n <- 0
#Create CV dataframe
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv[, paste0("CV", 1:ns_opt )] <-
SRS_Pop_CV[[isample]][, spp_idx_opt]
while (current_n <= c(280, 550, 820)[isample] ) {
#Set wd for output files, create a directory if it doesn"t exist yet
temp_dir = paste0(github_dir, "boat", isample, "/Run", Run)
if(!dir.exists(temp_dir)) dir.create(temp_dir, recursive = T)
setwd(temp_dir)
#Run optimization
solution <- optimStrata(method = "continuous",
errors = cv,
framesamp = frame,
iter = 300,
pops = 30,
elitism_rate = 0.1,
mut_chance = 1 / (c(5,5,5,5,5) + 1),
nStrata = c(5,5,5,5,5),
showPlot = T,
writeFiles = T,
parallel = T)
sum_stats <- summaryStrata(solution$framenew,
solution$aggr_strata,
progress=FALSE)
plot_solution <- as.factor(paste(solution$framenew$DOMAINVALUE,
solution$framenew$STRATO))
plot_solution <- as.integer(plot_solution)
#Plot Solution
goa <- sp::SpatialPointsDataFrame(
coords = Extrapolation_depths[,c("E_km", "N_km")],
data = data.frame(Str_no = plot_solution) )
goa_ras <- raster::raster(x = goa,
resolution = 5)
goa_ras <- raster::rasterize(x = goa,
y = goa_ras,
field = "Str_no")
png(filename = "solution.png",
width = 5,
height = 5,
units = "in",
res = 500)
plot(goa_ras, axes = F,
col = sample(terrain.colors(20)) )
dev.off()
#Save Output
CV_constraints <- expected_CV(strata = solution$aggr_strata)
current_n <- sum(sum_stats$Allocation)
result_list <- list(solution = solution,
sum_stats = sum_stats,
CV_constraints = CV_constraints,
n = current_n)
save(list = "result_list", file = "result_list.RData")
#Set up next run by changing upper CV constraints
Run <- Run + 1
CV_constraints <- 0.95*CV_constraints + 0.05*(SS_STRS_Pop_CV[[isample]])
#Create CV dataframe in the formmat of SamplingStrata
cv <- data.frame("DOM" = 1:5,
domainvalue = 1:5)
cv[, paste0("CV", 1:ns_opt )] <- CV_constraints
}
source('~/GitHub/Optimal_Allocation_GoA/analysis_scripts/Survey_Optimization.R', echo=TRUE)
sum_stats
sum_stats
