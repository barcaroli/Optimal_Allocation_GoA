do_STRS(
input <- list(
"density" = D_gct[,,Years2Include],
"obs_error_cv" = obs_errors_cv[ierror],
"solution" = switch(
isurvey,
"Current" = Extrapolation_depths$stratum,
"STRS" = res_df[, 1 + idx]),
"allocation" = switch(
isurvey,
"Current" = allocations[, paste0("boat", iboat)],
"STRS" = strata_list[[idx]]$Allocation),
"true_density" = true_mean )
)
stmt <- paste0(isurvey, "_sim_mean",
"[ierror, , , iboat, iter] = sim_survey$mean_denisty")
eval(parse(text = stmt))
stmt <- paste0(isurvey, "_sim_cv",
"[ierror, , , iboat, iter] = sim_survey$cv")
eval(parse(text = stmt))
stmt <- paste0(isurvey, "_rel_bias_est",
"[ierror, , , iboat, iter] = sim_survey$rel_bias")
eval(parse(text = stmt))
}
}
}
if(iter%%10 == 0) print(paste("Finished with Iteration", iter))
}
##################################
## Calculate Performance Metric
##################################
for (ierror in 1:n_obs_err) {
for (iboat in 1:3) {
for (isurvey in c("Current", "STRS")) {
for (ispp in 1:ns) {
for(iyear in 1:NTime) {
stmt <- paste0(isurvey, "_true_cv_array[ierror, iyear, ispp, iboat]",
" <- temp_true_cv <- sd(",
isurvey, "_sim_mean[ierror, iyear, ispp, iboat,], na.rm = TRUE) / ",
"true_mean[iyear, ispp]")
eval(parse(text = stmt))
temp_sim_cv <- get(paste0(isurvey,
"_sim_cv"))[ierror, iyear, ispp, iboat, ]
stmt <- paste0(isurvey, "_rrmse_cv_array[ierror, iyear, ispp, iboat]",
" <- sqrt(mean((temp_sim_cv - temp_true_cv)^2, na.rm = TRUE)) / ",
"mean(temp_sim_cv, na.rm = TRUE)")
eval(parse(text = stmt))
}
}
}
}
}
round(Current_true_cv_array[2, , 10, 2], 3)
round(STRS_true_cv_array[2, , 10, 2], 3)
par(mar = c(3,12,1,1), mfrow = c(2,1))
boxplot(apply(STRS_rel_bias_est[2, , , 2, ], MARGIN = 1:2, median, na.rm = T),
horizontal = T,
ylim = c(-20, 5),
las = 1)
abline(v = 0)
obs_CV
obs_errors_cv
par(mar = c(3,12,1,1), mfrow = c(2,1))
boxplot(apply(STRS_rel_bias_est[4, , , 2, ], MARGIN = 1:2, median, na.rm = T),
horizontal = T,
ylim = c(-20, 5),
las = 1)
abline(v = 0)
boxplot(apply(Current_rel_bias_est[4, , , 2, ], MARGIN = 1:2, median, na.rm = T),
horizontal = T,
ylim = c(-20, 5),
las = 1)
abline(v = 0)
boxplot(apply(Current_rel_bias_est[4, , , 2, ], MARGIN = 1:2, median, na.rm = T),
horizontal = T,
ylim = c(-20, 5),
las = 1)
apply(Current_rel_bias_est[4, , , 2, ], MARGIN = 1:2, median, na.rm = T)
par(mar = c(3,12,1,1), mfrow = c(2,1))
boxplot(apply(STRS_rel_bias_est[4, , , 2, ], MARGIN = 1:2, median, na.rm = T),
horizontal = T,
ylim = c(-20, 5),
las = 1)
abline(v = 0)
par(mar = c(3,12,1,1), mfrow = c(1,1))
boxplot(apply(STRS_rel_bias_est[4, , , 2, ], MARGIN = 1:2, median, na.rm = T),
horizontal = T,
ylim = c(-20, 5),
las = 1)
abline(v = 0)
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
# t(Current_true_cv_array[1:3, , ispp, 2])
t(STRS_true_cv_array[1:3, , ispp, 2])
),
las = 1
)
}
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
# t(Current_true_cv_array[1:3, , ispp, 2])
t(STRS_true_cv_array[1:4, , ispp, 2])
),
las = 1
)
}
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
# t(Current_rrmse_cv_array[1:3, , ispp, 2])
t(STRS_rrmse_cv_array[1:3, , ispp, 2])
),
las = 1
)
}
for (iter in 1:100) {
set.seed(1000 + iter)
for (ierror in 1:n_obs_err) {
for (iboat in 2) {
for (isurvey in c("Current", "STRS")) { #Current or Optimized Survey
if(isurvey == "STRS") {
#Load optimization data, only focusing on 15 strata for now
sub_settings = subset(settings, strata == 15)
which_idx <- which.min(abs(sub_settings$n - samples[iboat]))
idx <- sub_settings$id[which_idx]
}
sim_survey <-
do_STRS(
input <- list(
"density" = D_gct[,,Years2Include],
"obs_error_cv" = obs_errors_cv[ierror],
"solution" = switch(
isurvey,
"Current" = Extrapolation_depths$stratum,
"STRS" = res_df[, 1 + idx]),
"allocation" = switch(
isurvey,
"Current" = allocations[, paste0("boat", iboat)],
"STRS" = strata_list[[idx]]$Allocation),
"true_density" = true_mean )
)
stmt <- paste0(isurvey, "_sim_mean",
"[ierror, , , iboat, iter] = sim_survey$mean_denisty")
eval(parse(text = stmt))
stmt <- paste0(isurvey, "_sim_cv",
"[ierror, , , iboat, iter] = sim_survey$cv")
eval(parse(text = stmt))
stmt <- paste0(isurvey, "_rel_bias_est",
"[ierror, , , iboat, iter] = sim_survey$rel_bias")
eval(parse(text = stmt))
}
}
}
if(iter%%10 == 0) print(paste("Finished with Iteration", iter))
}
##################################
## Calculate Performance Metric
##################################
for (ierror in 1:n_obs_err) {
for (iboat in 1:3) {
for (isurvey in c("Current", "STRS")) {
for (ispp in 1:ns) {
for(iyear in 1:NTime) {
stmt <- paste0(isurvey, "_true_cv_array[ierror, iyear, ispp, iboat]",
" <- temp_true_cv <- sd(",
isurvey, "_sim_mean[ierror, iyear, ispp, iboat,], na.rm = TRUE) / ",
"true_mean[iyear, ispp]")
eval(parse(text = stmt))
temp_sim_cv <- get(paste0(isurvey,
"_sim_cv"))[ierror, iyear, ispp, iboat, ]
stmt <- paste0(isurvey, "_rrmse_cv_array[ierror, iyear, ispp, iboat]",
" <- sqrt(mean((temp_sim_cv - temp_true_cv)^2, na.rm = TRUE)) / ",
"mean(temp_sim_cv, na.rm = TRUE)")
eval(parse(text = stmt))
}
}
}
}
}
par(mar = c(3,12,1,1), mfrow = c(1,1))
boxplot(apply(STRS_rel_bias_est[4, , , 2, ], MARGIN = 1:2, median, na.rm = T),
horizontal = T,
ylim = c(-20, 5),
las = 1)
abline(v = 0)
obs_errors_cv
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
# t(Current_true_cv_array[1:3, , ispp, 2])
t(STRS_true_cv_array[1:4, , ispp, 2])
),
las = 1
)
}
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
# t(Current_rrmse_cv_array[1:3, , ispp, 2])
t(STRS_rrmse_cv_array[1:3, , ispp, 2])
),
las = 1
)
}
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
t(Current_rrmse_cv_array[1:3, , ispp, 2])
# t(STRS_rrmse_cv_array[1:3, , ispp, 2])
),
las = 1
)
}
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
t(Current_rrmse_cv_array[1, , ispp, 2]),
t(STRS_rrmse_cv_array[1, , ispp, 2])
),
las = 1
)
}
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
t(Current_rrmse_cv_array[1:2, , ispp, 2]),
t(STRS_rrmse_cv_array[1:2, , ispp, 2])
),
las = 1
)
}
par(mfrow = c(5,3), mar = c(1,3,1,1))
for (ispp in 1:ns) {
boxplot(cbind(
# t(Current_rrmse_cv_array[1:2, , ispp, 2]),
t(STRS_rrmse_cv_array[1:4, , ispp, 2])
),
las = 1
)
}
##################################################
####   Result Objects
##################################################
obs_errors_cv <- c("none" = 0, "low" = 0.25, "high" = 0.5, "veryhigh" = 1)
n_obs_err <- length(obs_errors_cv)
Current_sim_mean <- Current_sim_cv <- Current_rel_bias_est <-
STRS_sim_mean <- STRS_sim_cv <- STRS_rel_bias_est <-
array(dim = c(n_obs_err, NTime, ns, nboats, Niters),
dimnames = list(names(obs_errors_cv),
paste0("year_", 1:NTime),
sci_names,
paste0("boat_", 1:3),
NULL ))
Current_true_cv_array <- Current_rrmse_cv_array <-
STRS_true_cv_array <- STRS_rrmse_cv_array <-
array(dim = c(n_obs_err, NTime, ns, nboats),
dimnames = list(names(obs_errors_cv),
paste0("year_", 1:NTime),
sci_names,
paste0("boat_", 1:3)))
for (iter in 1:100) {
set.seed(1000 + iter)
for (ierror in 1:n_obs_err) {
for (iboat in 2) {
for (isurvey in c("Current", "STRS")) { #Current or Optimized Survey
if(isurvey == "STRS") {
#Load optimization data, only focusing on 15 strata for now
sub_settings = subset(settings, strata == 15)
which_idx <- which.min(abs(sub_settings$n - samples[iboat]))
idx <- sub_settings$id[which_idx]
}
sim_survey <-
do_STRS(
input <- list(
"density" = D_gct[,,Years2Include],
"obs_error_cv" = obs_errors_cv[ierror],
"solution" = switch(
isurvey,
"Current" = Extrapolation_depths$stratum,
"STRS" = res_df[, 1 + idx]),
"allocation" = switch(
isurvey,
"Current" = allocations[, paste0("boat", iboat)],
"STRS" = strata_list[[idx]]$Allocation),
"true_density" = true_mean )
)
stmt <- paste0(isurvey, "_sim_mean",
"[ierror, , , iboat, iter] = sim_survey$mean_denisty")
eval(parse(text = stmt))
stmt <- paste0(isurvey, "_sim_cv",
"[ierror, , , iboat, iter] = sim_survey$cv")
eval(parse(text = stmt))
stmt <- paste0(isurvey, "_rel_bias_est",
"[ierror, , , iboat, iter] = sim_survey$rel_bias")
eval(parse(text = stmt))
}
}
}
if(iter%%10 == 0) print(paste("Finished with Iteration", iter))
}
##################################
## Calculate Performance Metric
##################################
for (ierror in 1:n_obs_err) {
for (iboat in 1:3) {
for (isurvey in c("Current", "STRS")) {
for (ispp in 1:ns) {
for(iyear in 1:NTime) {
stmt <- paste0(isurvey, "_true_cv_array[ierror, iyear, ispp, iboat]",
" <- temp_true_cv <- sd(",
isurvey, "_sim_mean[ierror, iyear, ispp, iboat,], na.rm = TRUE) / ",
"true_mean[iyear, ispp]")
eval(parse(text = stmt))
temp_sim_cv <- get(paste0(isurvey,
"_sim_cv"))[ierror, iyear, ispp, iboat, ]
stmt <- paste0(isurvey, "_rrmse_cv_array[ierror, iyear, ispp, iboat]",
" <- sqrt(mean((temp_sim_cv - temp_true_cv)^2, na.rm = TRUE)) / ",
"mean(temp_sim_cv, na.rm = TRUE)")
eval(parse(text = stmt))
}
}
}
}
}
##################################################
####  Import required packages
##################################################
library(SamplingStrata)
install.packages("SamplingStrata")
## Project:       Data synthesis for stratified survey optimization
## Author:        Zack Oyafuso (zack.oyafuso@noaa.gov)
## Description:   Create dataset used for all optimization runs based on a
##                Gulf of Alaska groundfish VAST spatiotemporal
##                operating single-species models
##
##                Calculate true mean density across years for each species
##
##                Set up other constants used in downstream processes
###############################################################################
rm(list = ls())
##################################################
####  Import required packages
##################################################
library(SamplingStrata)
##################################################
####    Set up directories
##################################################
which_machine <- c("Zack_MAC" = 1, "Zack_PC" = 2, "Zack_GI_PC" = 3)[3]
install.packages('here')
libary(here)
library(here)
here()
getwd()
dir()
library(here)
library(here)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
#Create CV dataframe in the formmat of SamplingStrata
cv <- list()
for (spp in 1:ns_opt)
cv[[paste0("CV", spp)]] <- as.numeric(CV_constraints[spp])
cv[["DOM"]] <- 1
cv[["domainvalue"]] <- 1
cv <- as.data.frame(cv)
while (current_n <= c(280, 550, 820)[isample] ) {
#Set wd for output files, create a directory if it doesn"t exist yet
temp_dir = paste0(github_dir, "boat", isample, "/Str", temp_strata,
"Run", Run)
if(!dir.exists(temp_dir)) dir.create(temp_dir, recursive = T)
setwd(temp_dir)
#Run optimization
solution <- optimStrata(method = "continuous",
errors = cv,
framesamp = frame,
iter = 300,
pops = 30,
elitism_rate = 0.1,
mut_chance = 1 / (temp_strata + 1),
nStrata = temp_strata,
showPlot = T,
writeFiles = T)
sum_stats <- summaryStrata(solution$framenew,
solution$aggr_strata,
progress=FALSE)
#Plot Solution
goa <- sp::SpatialPointsDataFrame(
coords = Extrapolation_depths[,c("E_km", "N_km")],
data = data.frame(Str_no = solution$framenew$STRATO) )
goa_ras <- raster::raster(x = goa,
resolution = 5)
goa_ras <- raster::rasterize(x = goa,
y = goa_ras,
field = "Str_no")
png(filename = "solution.png",
width = 5,
height = 5,
units = "in",
res = 500)
plot(goa_ras, axes = F,
col = terrain.colors(temp_strata)[sample(temp_strata)])
dev.off()
#Save Output
CV_constraints <- expected_CV(strata = solution$aggr_strata)
current_n <- sum(sum_stats$Allocation)
result_list <- list(solution = solution,
sum_stats = sum_stats,
CV_constraints = CV_constraints,
n = current_n)
save(list = "result_list", file = "result_list.RData")
#Set up next run by changing upper CV constraints
Run <- Run + 1
CV_constraints <- 0.9*CV_constraints + 0.1*(SS_STRS_Pop_CV[, isample])
#Create CV dataframe in the formmat of SamplingStrata
cv <- list()
for (spp in 1:ns_opt)
cv[[paste0("CV", spp)]] <- as.numeric(CV_constraints[spp])
cv[["DOM"]] <- 1
cv[["domainvalue"]] <- 1
cv <- as.data.frame(cv)
}
cv <- as.data.frame(cv)
#Save Output
CV_constraints <- expected_CV(strata = solution$aggr_strata)
current_n <- sum(sum_stats$Allocation)
result_list <- list(solution = solution,
sum_stats = sum_stats,
CV_constraints = CV_constraints,
n = current_n)
save(list = "result_list", file = "result_list.RData")
#Set up next run by changing upper CV constraints
Run <- Run + 1
CV_constraints <- 0.95*CV_constraints + 0.1*(SS_STRS_Pop_CV[, isample])
#Create CV dataframe in the formmat of SamplingStrata
cv <- list()
for (spp in 1:ns_opt)
cv[[paste0("CV", spp)]] <- as.numeric(CV_constraints[spp])
cv[["DOM"]] <- 1
cv[["domainvalue"]] <- 1
cv <- as.data.frame(cv)
while (current_n <= c(280, 550, 820)[isample] ) {
#Set wd for output files, create a directory if it doesn"t exist yet
temp_dir = paste0(github_dir, "boat", isample, "/Str", temp_strata,
"Run", Run)
if(!dir.exists(temp_dir)) dir.create(temp_dir, recursive = T)
setwd(temp_dir)
#Run optimization
solution <- optimStrata(method = "continuous",
errors = cv,
framesamp = frame,
iter = 300,
pops = 30,
elitism_rate = 0.1,
mut_chance = 1 / (temp_strata + 1),
nStrata = temp_strata,
showPlot = T,
writeFiles = T)
sum_stats <- summaryStrata(solution$framenew,
solution$aggr_strata,
progress=FALSE)
#Plot Solution
goa <- sp::SpatialPointsDataFrame(
coords = Extrapolation_depths[,c("E_km", "N_km")],
data = data.frame(Str_no = solution$framenew$STRATO) )
goa_ras <- raster::raster(x = goa,
resolution = 5)
goa_ras <- raster::rasterize(x = goa,
y = goa_ras,
field = "Str_no")
png(filename = "solution.png",
width = 5,
height = 5,
units = "in",
res = 500)
plot(goa_ras, axes = F,
col = terrain.colors(temp_strata)[sample(temp_strata)])
dev.off()
#Save Output
CV_constraints <- expected_CV(strata = solution$aggr_strata)
current_n <- sum(sum_stats$Allocation)
result_list <- list(solution = solution,
sum_stats = sum_stats,
CV_constraints = CV_constraints,
n = current_n)
save(list = "result_list", file = "result_list.RData")
#Set up next run by changing upper CV constraints
Run <- Run + 1
CV_constraints <- 0.95*CV_constraints + 0.1*(SS_STRS_Pop_CV[, isample])
#Create CV dataframe in the formmat of SamplingStrata
cv <- list()
for (spp in 1:ns_opt)
cv[[paste0("CV", spp)]] <- as.numeric(CV_constraints[spp])
cv[["DOM"]] <- 1
cv[["domainvalue"]] <- 1
cv <- as.data.frame(cv)
}
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
