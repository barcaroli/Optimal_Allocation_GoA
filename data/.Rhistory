Z = sim_Z(log_mean = log(0.2)) )
##################################################
####    Simulate Abundance for a long- vs short-lived population
##################################################
set.seed(438)
long <- sim_abundance(ages = 1:20,
R = sim_R(log_mean = log(3e+07)),
Z = sim_Z(log_mean = log(0.2)) )
short <- sim_abundance(ages = 1:6,
R = sim_R(log_mean = log(1e+10)),
Z = sim_Z(log_mean = log(0.8)))
lon
long
long
str(long)
long$ages
long$lengths
long$N
long$N0
long$lengths
long$R
long$Z
short <- sim_abundance(ages = 1:6,
R = sim_R(log_mean = log(1e+10),
log_sd = 0.5),
Z = sim_Z(log_mean = log(0.8),
log_sd = 0.2,
phi_age = 0.9, #age-correlation on Z
phi_year = 0.5) #year-correlation on Z
)
#############################################################################
## Project:       SimSurvey Vignette
## Author:        Zack Oyafuso (zack.oyafuso@noaa.gov)
##                Developed by Paul Regular
## Description:
###############################################################################
rm(list = ls())
##################################################
####    Import required packages
##################################################
# install.packages("remotes")
# library(remotes)
# remotes::install_github("PaulRegular/SimSurvey")
library(SimSurvey)
##################################################
####    Simulate Recruitment
####    "Closures": functions that contain data and return functions
####    sim_R: simulate recruitment values lognormal distribution
####    Custom closures can be applied for more Stock-Recruit Functions
##################################################
R_fun <- SimSurvey::sim_R(log_mean = log(500),
log_sd = 0.5)
R_vec <- R_fun(years = 1:100)
##################################################
####    Simulate Abundance for a long- vs short-lived population
##################################################
set.seed(438)
long <- sim_abundance(ages = 1:20,
R = sim_R(log_mean = log(3e+07),
log_sd = 0.5),
Z = sim_Z(log_mean = log(0.2),
log_sd = 0.2,
phi_age = 0.9, #age-correlation on Z
phi_year = 0.5) #year-correlation on Z
)
short <- sim_abundance(ages = 1:6,
R = sim_R(log_mean = log(1e+10),
log_sd = 0.5),
Z = sim_Z(log_mean = log(0.8),
log_sd = 0.2,
phi_age = 0.9, #age-correlation on Z
phi_year = 0.5) #year-correlation on Z
)
##################################################
####
##################################################
##################################################
####
##################################################
##################################################
####
##################################################
##################################################
####
##################################################
##################################################
####
##################################################
plot_surface(long, mat = "N")
plot_surface(short, mat = "N")
?make_grid
##################################################
####    Spatial Domain
##################################################
a = SimSurvey::make_grid(n_div = 1,
strat_splits = 2,
shelf_depth = 200,
shelf_width = 100,
depth_range = c(0, 1000))
plot(a)
plot_grid(a)
c = SimSurvey::make_grid(n_div = 4,
strat_splits = 1,
shelf_depth = 0,
shelf_width = 500,
depth_range = c(0, 1000))
b = SimSurvey::make_grid(n_div = 1,
strat_splits = 3,
shelf_depth = 200,
shelf_width = 100,
depth_range = c(0, 1000))
SimSurvey::plot_grid(b)
c = SimSurvey::make_grid(n_div = 4,
strat_splits = 1,
shelf_depth = 0,
shelf_width = 500,
depth_range = c(0, 1000))
SimSurvey::plot_grid(a)
SimSurvey::plot_grid(c)
SimSurvey::plot_grid(a)
c = SimSurvey::make_grid(n_div = 4,
strat_splits = 1,
shelf_depth = 500,
shelf_width = 0,
depth_range = c(0, 1000))
SimSurvey::plot_grid(c)
SimSurvey::plot_grid(a)
SimSurvey::plot_grid(c)
SimSurvey::plot_grid(a)
SimSurvey::plot_grid(b)
SimSurvey::plot_grid(c)
##################################################
####    Simulate Distribution across domain?
##################################################
set.seed(438)
sim_abundance()
a = sim_distribution(
sim = sim_abundance(),
ays_covar = sim_ays_covar(range = 300, #km, clustered
phi_year = 0.9,
phi_age = 0.5))
b = sim_distribution(
sim = sim_abundance(),
ays_covar = sim_ays_covar(range = 2000, #km, diffuse
phi_year = 0.2,
phi_age = 0.9))
SimSurvey::plot_distribution(a, ages = 1:3, type = 'heatmap')
SimSurvey::plot_distribution(b, ages = 1:3, type = 'heatmap')
##################################################
####    Simulate a Survey
##################################################
set.seed(438)
pop = sim_distribution(sim = sim_abundance())
?SimSurvey::sim_survey()
?sim_survey
a <- SimSurvey::sim_survey(sim = pop,
n_sims = 5,
set_den = 1/1000,
lengths_cap = 100,
ages_cap = 5)
b <- SimSurvey::sim_survey(sim = pop,
n_sims = 5,
set_den = 5/1000,
lengths_cap = 500,
ages_cap = 25)
str(a)
str(a$samp_totals)
str(a)
table(a$samp$set)
a$setdet
str(a$setdet)
table(a$setdet$set)
summary(a$setdet$set)
str(a$setdet)
table(a$setdet$sim)
table(a$setdet$sim, a$setdet$year)
a$I
str(a$setdet)
table(a$setdet$strat)
str(a$setdet)
3.5*3.5
##################################################
####    Stratified Estimates of abundance
##################################################
SimSurvey::run_strat(sim = a)
##################################################
####    Stratified Estimates of abundance
##################################################
a_run_strata = SimSurvey::run_strat(sim = a)
##################################################
####    Stratified Estimates of abundance
##################################################
a_run_strat = SimSurvey::run_strat(sim = a)
rm(a_run_strata)
a_run_strata
a_run_strat
str(a_run_strat)
str(a_run_strat)
a_strat_error = SimSurvey::strat_error(sim = a_run_strat)
a_strat_error
str(a_strat_error)
## Required libraries for data processing
library("sp")
library("rgdal")
library("raster")
## Function for converting long and lat values in DAT files
llconvert <- function(x) {
ifelse(as.numeric(substring(x, 1, 2)) != 0,
as.numeric(substring(x,1,2)) +
(as.numeric(substring(x,3,4)) +
as.numeric(substring(x,5,5))/10)/60,
NA)
}
## Index strata for 3Ps
index_strata <- c(293:300, 306:326, 705:708, 711:716, 779:783)
## UTM projection for Newfoundland
utm_proj <- "+proj=utm +zone=21 +ellps=WGS84 +datum=WGS84 +units=km +no_defs"
setwd('C:/Users/zack.oyafuso/Work/GitHub/SimSurvey/')
## Required libraries for data processing
library("sp")
library("rgdal")
library("raster")
## Function for converting long and lat values in DAT files
llconvert <- function(x) {
ifelse(as.numeric(substring(x, 1, 2)) != 0,
as.numeric(substring(x,1,2)) +
(as.numeric(substring(x,3,4)) +
as.numeric(substring(x,5,5))/10)/60,
NA)
}
## Index strata for 3Ps
index_strata <- c(293:300, 306:326, 705:708, 711:716, 779:783)
## UTM projection for Newfoundland
utm_proj <- "+proj=utm +zone=21 +ellps=WGS84 +datum=WGS84 +units=km +no_defs"
## Import 3Ps strata shapefile
strat_polys <- readOGR("data-raw/DFO_NL_survey_strat/2HJ3KLNOP_Strata_Polygons_WGS84.shp",
layer = "2HJ3KLNOP_Strata_Polygons_WGS84")
strat_polys <- strat_polys[strat_polys$DIV == "3P", ] # subset to 3P
strat_polys <- strat_polys[strat_polys$STRAT %in% index_strata, ] # 3Ps index strata
strat_polys_utm <- spTransform(strat_polys, utm_proj)
plot(strat_polys)
## Survey area extent + a buffer
survey_extent <- bbox(strat_polys_utm)
b <- 120 # km buffer
survey_extent[, "min"] <- survey_extent[, "min"] - b
survey_extent[, "max"] <- survey_extent[, "max"] + b
survey_extent <- extent(survey_extent)
survey_extent
plot(strat_polys_utm)
## Import land data
can <- raster::getData("GADM", country = "CAN", level = 1, path = "data-raw/GADM_data")
nl <- can[can$NAME_1 == "Newfoundland and Labrador", ]
spm <- raster::getData("GADM", country = "SPM", level = 1, path = "data-raw/GADM_data")
row.names(nl) <- paste("NL", row.names(nl), sep = "_") # provide unique ID's before attempting rbind
row.names(spm) <- paste("SPM", row.names(spm), sep = "_")
nl <- rbind(nl, spm)
nl_utm <- spTransform(nl, CRS(utm_proj))
nl_utm <- raster::crop(nl_utm, survey_extent)
nl_utm <- rgeos::gSimplify(nl_utm, tol = 0.2) # simplify the land object
plot(nl_utm)
## Import GEBCO derived bathymetry data
## "NAFO_GEBCO_data.nc" file was downloaded from http://www.gebco.net/.
##  Only provide derived data in data-raw folder for licensing reasons
# bathy <- raster("data-raw/GEBCO_derived_bathy/NAFO_GEBCO_data.nc")
# bathy <- raster::crop(bathy, extent(-65, -45, 42, 50)) # coarse crop
# bathy_utm <- raster::projectRaster(bathy, crs = utm_proj)
# r <- raster(survey_extent, res = c(1, 1), crs = utm_proj)
# bathy_utm <- resample(bathy_utm, r, method = "bilinear") # interpolate to 1 x 1 km utm grid
# save(bathy_utm, file = "data-raw/GEBCO_derived_bathy/GEBCO_derived_bathy.Rdata")
load("data-raw/GEBCO_derived_bathy/GEBCO_derived_bathy.Rdata")
## Import 3PS survey units
survey_units <- read.table("data-raw/DFO_NL_survey_units/POS3P.DAT", header = FALSE)
names(survey_units) <- c("division", "strat", "unit_num", "lat", "lon")
survey_units <- survey_units[survey_units$strat %in% index_strata, ]
survey_units$lat <- llconvert(survey_units$lat)
survey_units$lon <- -llconvert(survey_units$lon)
coordinates(survey_units) <- ~ lon + lat
proj4string(survey_units) <- proj4string(strat_polys)
survey_units_utm <- spTransform(survey_units, crs(utm_proj))
## Clean-up some unused objects
rm(strat_polys, nl, survey_units)
survey_units_utm
plot(survey_units_utm)
## Build survey grid - approximate the resolution of the actual survey
plot(strat_polys_utm)
plot(survey_units_utm, add = TRUE, pch = ".", col = "red")
nunits <- length(survey_units_utm)
survey_grid <- spsample(strat_polys_utm, n = nunits, type = "regular")
plot(survey_grid, add = TRUE, col = "blue", pch = ".")
survey_grid <- as(survey_grid, "SpatialPixels")
dat <- data.frame(cell = seq.int(length(survey_grid)))
survey_grid <- SpatialPixelsDataFrame(survey_grid, dat)
survey_grid <- raster(survey_grid)
names(survey_grid) <- "cell"
## Add division, strat and depth
survey_grid$division <- rasterize(strat_polys_utm, survey_grid, "DIV")
survey_grid$strat <- rasterize(strat_polys_utm, survey_grid, "STRAT")
survey_grid$depth <- resample(bathy_utm, survey_grid, method = "bilinear")
values(survey_grid$depth)[is.na(values(survey_grid$cell))] <- NA
values(survey_grid$depth) <- -values(survey_grid$depth)
plot(survey_grid)
## Make sure the number of cells are equal across the stack
lapply(names(survey_grid), function(nm) sum(!is.na(values(survey_grid[[nm]]))))
plot(nw)
plot(nl)
nl <- can[can$NAME_1 == "Newfoundland and Labrador", ]
## Import land data
can <- raster::getData("GADM", country = "CAN", level = 1, path = "data-raw/GADM_data")
nl <- can[can$NAME_1 == "Newfoundland and Labrador", ]
spm <- raster::getData("GADM", country = "SPM", level = 1, path = "data-raw/GADM_data")
row.names(nl) <- paste("NL", row.names(nl), sep = "_") # provide unique ID's before attempting rbind
row.names(spm) <- paste("SPM", row.names(spm), sep = "_")
nl <- rbind(nl, spm)
nl_utm <- spTransform(nl, CRS(utm_proj))
nl_utm <- raster::crop(nl_utm, survey_extent)
nl_utm <- rgeos::gSimplify(nl_utm, tol = 0.2) # simplify the land object
plot(nl_utm)
plot(survey_grid)
plot(nl, add = T)
plot(nl_utm, add = T)
## Build survey grid - approximate the resolution of the actual survey
plot(strat_polys_utm)
plot(nl_utm, add = T)
plot(nl_utm, add = T, col = 'tan')
land <- nl_utm
bathy <- bathy_utm
survey_grid
plot(survey_grid)
values(survey_grid$depth)
sum(is.na(values(survey_grid$depth)))
sum(!is.na(values(survey_grid$depth)))
survey_grid
survey_grid$depth
#############################################################################
## Project:       SimSurvey Vignette
## Author:        Zack Oyafuso (zack.oyafuso@noaa.gov)
##                Developed by Paul Regular
## Description:
###############################################################################
rm(list = ls())
library(SimSurvey)
##################################################
####    Simulate Recruitment
####    "Closures": functions that contain data and return functions
####    sim_R: simulate recruitment values lognormal distribution
####    Custom closures can be applied for more Stock-Recruit Functions
##################################################
R_fun <- SimSurvey::sim_R(log_mean = log(500),
log_sd = 0.5)
R_vec <- R_fun(years = 1:100)
##################################################
####    Spatial Domain
##################################################
a = SimSurvey::make_grid(n_div = 1,
strat_splits = 2,
shelf_depth = 200,
shelf_width = 100,
depth_range = c(0, 1000))
str(a)
plot(a)
setwd('C:/Users/zack.oyafuso/Work/GitHub/Optimal_Allocation_GoA/data')
goa_grid <- load('Extrapolation_depths.RData')
setwd("C:/Users/zack.oyafuso/Work/GitHub/Optimal_Allocation_GoA/data")
goa_grid <- load('Extrapolation_depths.RData')
library(SimSurvey)
head(goa_grid)
load('Extrapolation_depths.RData')
head(Extrapolation_depths)
goa <- SpatialPointsDataFrame(
coords = Extrapolation_depths[,c("E_km", "N_km")],
data = Extrapolation_depths )
goa_ras <- raster(goa, resolution = 5)
goa_ras
goa_ras <- rasterize(x = goa, y = goa_ras, field = "depth")
plot(goa_ras)
goa_ras
sum(!is.na(values(goa_ras)))
sum(is.na(values(goa_ras)))
?spsample
setwd('C:/Users/zack.oyafuso/Work/GitHub/SimSurvey/')
## Required libraries for data processing
library("sp")
library("rgdal")
library("raster")
## Function for converting long and lat values in DAT files
llconvert <- function(x) {
ifelse(as.numeric(substring(x, 1, 2)) != 0,
as.numeric(substring(x,1,2)) +
(as.numeric(substring(x,3,4)) +
as.numeric(substring(x,5,5))/10)/60,
NA)
}
## Index strata for 3Ps
index_strata <- c(293:300, 306:326, 705:708, 711:716, 779:783)
## UTM projection for Newfoundland
utm_proj <- "+proj=utm +zone=21 +ellps=WGS84 +datum=WGS84 +units=km +no_defs"
## Import 3Ps strata shapefile
strat_polys <- readOGR("data-raw/DFO_NL_survey_strat/2HJ3KLNOP_Strata_Polygons_WGS84.shp",
layer = "2HJ3KLNOP_Strata_Polygons_WGS84")
strat_polys <- strat_polys[strat_polys$DIV == "3P", ] # subset to 3P
strat_polys <- strat_polys[strat_polys$STRAT %in% index_strata, ] # 3Ps index strata
strat_polys_utm <- spTransform(strat_polys, utm_proj)
## Survey area extent + a buffer
survey_extent <- bbox(strat_polys_utm)
b <- 120 # km buffer
survey_extent[, "min"] <- survey_extent[, "min"] - b
survey_extent[, "max"] <- survey_extent[, "max"] + b
survey_extent <- extent(survey_extent)
## Import land data
can <- raster::getData("GADM", country = "CAN", level = 1, path = "data-raw/GADM_data")
nl <- can[can$NAME_1 == "Newfoundland and Labrador", ]
spm <- raster::getData("GADM", country = "SPM", level = 1, path = "data-raw/GADM_data")
row.names(nl) <- paste("NL", row.names(nl), sep = "_") # provide unique ID's before attempting rbind
row.names(spm) <- paste("SPM", row.names(spm), sep = "_")
nl <- rbind(nl, spm)
nl_utm <- spTransform(nl, CRS(utm_proj))
nl_utm <- raster::crop(nl_utm, survey_extent)
nl_utm <- rgeos::gSimplify(nl_utm, tol = 0.2) # simplify the land object
plot(nl_utm)
## Import GEBCO derived bathymetry data
## "NAFO_GEBCO_data.nc" file was downloaded from http://www.gebco.net/.
##  Only provide derived data in data-raw folder for licensing reasons
# bathy <- raster("data-raw/GEBCO_derived_bathy/NAFO_GEBCO_data.nc")
# bathy <- raster::crop(bathy, extent(-65, -45, 42, 50)) # coarse crop
# bathy_utm <- raster::projectRaster(bathy, crs = utm_proj)
# r <- raster(survey_extent, res = c(1, 1), crs = utm_proj)
# bathy_utm <- resample(bathy_utm, r, method = "bilinear") # interpolate to 1 x 1 km utm grid
# save(bathy_utm, file = "data-raw/GEBCO_derived_bathy/GEBCO_derived_bathy.Rdata")
load("data-raw/GEBCO_derived_bathy/GEBCO_derived_bathy.Rdata")
## Import 3PS survey units
survey_units <- read.table("data-raw/DFO_NL_survey_units/POS3P.DAT", header = FALSE)
names(survey_units) <- c("division", "strat", "unit_num", "lat", "lon")
survey_units <- survey_units[survey_units$strat %in% index_strata, ]
survey_units$lat <- llconvert(survey_units$lat)
survey_units$lon <- -llconvert(survey_units$lon)
coordinates(survey_units) <- ~ lon + lat
proj4string(survey_units) <- proj4string(strat_polys)
survey_units_utm <- spTransform(survey_units, crs(utm_proj))
## Clean-up some unused objects
rm(strat_polys, nl, survey_units)
## Build survey grid - approximate the resolution of the actual survey
plot(strat_polys_utm)
plot(survey_units_utm, add = TRUE, pch = ".", col = "red")
survey_units_utm
survey_units_utm
survey_units_utm@data
survey_units_utm@coords
nunits <- length(survey_units_utm)
nunits
nrow(survey_units_utm@coords)
survey_grid <- spsample(strat_polys_utm, n = nunits, type = "regular")
survey_grid
nunits
strat_polys_utm
plot(survey_grid, add = TRUE, col = "blue", pch = ".")
survey_grid
survey_grid <- as(survey_grid, "SpatialPixels")
survey_grid
dat <- data.frame(cell = seq.int(length(survey_grid)))
str(dat)
survey_grid <- SpatialPixelsDataFrame(survey_grid, dat)
survey_grid <- raster(survey_grid)
names(survey_grid) <- "cell"
survey_grid
survey_grid
survey_grid <- spsample(strat_polys_utm, n = nunits, type = "regular")
plot(survey_grid, add = TRUE, col = "blue", pch = ".")
## Build survey grid - approximate the resolution of the actual survey
plot(strat_polys_utm)
plot(survey_units_utm, add = TRUE, pch = ".", col = "red")
nunits <- length(survey_units_utm)
survey_grid <- spsample(strat_polys_utm, n = nunits, type = "regular")
plot(survey_grid, add = TRUE, col = "blue", pch = ".")
survey_grid <- as(survey_grid, "SpatialPixels")
dat <- data.frame(cell = seq.int(length(survey_grid)))
survey_grid <- SpatialPixelsDataFrame(survey_grid, dat)
survey_grid <- raster(survey_grid)
names(survey_grid) <- "cell"
strat_polys_utm
strat_polys
source('~/.active-rstudio-document', echo=TRUE)
goa
nunits <- length(goa)
nunits
survey_grid <- spsample(goa, n = nunits, type = "regular")
head(survey_grid)
plot(goa)
plot(survey_gird)
plot(survey_grid)
plot(survey_grid)
plot(goa)
points(survey_grid, col = 'red')
str(survey_grid)
str(goa)
survey_grid <- as(survey_grid, "SpatialPixels")
dat <- data.frame(cell = seq.int(length(survey_grid)))
dat
survey_grid <- SpatialPixelsDataFrame(survey_grid, dat)
survey_grid <- raster(survey_grid)
names(survey_grid) <- "cell"
survey_grid
head(goa)
survey_grid$division <- rasterize(goa, survey_grid, "Include")
survey_grid$strat <- rasterize(goa, survey_grid, "GOA_STRATUM")
survey_grid$depth <- rasterize(goa, survey_grid, method = "depth")
survey_grid$depth <- rasterize(goa, survey_grid, "depth")
survey_grid
survey_grid$cell
plot(survey_grid$cell)
plot(survey_grid$depth)
plot(survey_grid$strat)
(survey_grid$strat)
